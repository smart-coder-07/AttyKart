package com.order.service;
import java.util.Date;
import java.util.List;

import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientResponseException;

import com.order.exception.OrderNotFoundException;
import com.order.model.CartItem;
import com.order.model.Order;
import com.order.model.OrderItem;
import com.order.model.OrderPlacedEvent;
import com.order.model.Product;
import com.order.model.Transaction;
import com.order.model.User;
import com.order.model.Wallet;
import com.order.repository.OrderRepository;

import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class OrderServiceImpl implements OrderService {
    private final OrderRepository orderRepository;
    private final WebClient.Builder webClientBuilder;
    
    final static String mess = "Order not found with ID: ";

    @Override
    public Order placeOrder(Order order) {
        List<CartItem> cartItems = fetchCartItems(order.getUserId());
        if(cartItems.isEmpty()) {
        	throw new OrderNotFoundException("Cart is empty");
        }
        
        validateProductAvailability(cartItems);
        
        User user = findUserDetails(order.getUserId());

        List<OrderItem> orderItems = cartItems.stream()
                .map(cartItem -> new OrderItem(
                        cartItem.getProductId(),
                        cartItem.getProductName(),
                        cartItem.getPrice(),
                        cartItem.getQuantity(),
                        cartItem.getImage()
                ))
                .toList();

        double totalAmount = orderItems.stream()
                .mapToDouble(item -> item.getPrice() * item.getQuantity())
                .sum();
        Wallet wallet = new Wallet();
        wallet.setAmount(totalAmount);
        wallet.setUserId(order.getUserId());
        
        deductBalance(wallet);

        Transaction t = new Transaction();
        
        order.setOrderDate(new Date());
        order.setItems(orderItems);
        order.setTotalAmount(totalAmount);
        order.setOrderStatus("PENDING");
        order.setId(orderRepository.count()+1+"");
        t.setAmount(totalAmount);
        t.setOrderId(order.getId());
        t.setUserId(order.getUserId());
        t.setType("DEBIT");
        saveTransaction(t);
        
        Order savedOrder = orderRepository.save(order);
        OrderPlacedEvent event = new OrderPlacedEvent(
        	    user.getEmail(),
        	    "Order Confirmation - AttyCart",
        	    String.format(
        	        "Dear %s,\n\nYour order (ID: %s) has been placed successfully. \nTotal amount: â‚¹%.2f.\nThank you for shopping with us! \n\nTeam AttyCart...",
        	        user.getUsername().toUpperCase(), savedOrder.getId(), savedOrder.getTotalAmount()
        	    )
        	);
        sendNotification(event);
        return savedOrder;

    }

    private List<CartItem> fetchCartItems(String userId) {
        try {
            return webClientBuilder.build()
                    .get()
                    .uri("http://CARTSERVICE/user/" + userId)
                    .retrieve()
                    .bodyToFlux(CartItem.class)
                    .collectList()
                    .block();
        } catch (WebClientResponseException ex) {
            throw new OrderNotFoundException("Failed to fetch cart items: " + ex.getMessage());
        }
    }
    private void clearCartItems(String userId) {
    	try {
    		return webClientBuilder.build()
    				.delete()
    				.uri("http://CARTSERVICE/clear/" + userId)
    				.retrieve()
    				.bodyToFlux(CartItem.class)
    				.collectList()
    				.block();
    	} catch (WebClientResponseException ex) {
    		throw new OrderNotFoundException("Failed to fetch cart items: " + ex.getMessage());
    	}
    }

   
    private void validateProductAvailability(List<CartItem> cartItems) {
        for (CartItem item : cartItems) {
            try {
                Product product = webClientBuilder.build()
                        .get()
                        .uri("http://PRODUCTSERVICE/" + item.getProductId())
                        .retrieve()
                        .bodyToMono(Product.class)
                        .block();

                if (product == null || !"ACTIVE".equals(product.getStatus())) {
                    throw new OrderNotFoundException("Product " + item.getProductId() + " is not available.");
                }
            } catch (WebClientResponseException ex) {
                throw new OrderNotFoundException("Failed to validate product availability: " + ex.getMessage());
            }
        }
    }
    private void saveTransaction(Transaction transaction) {
    	try {
    				webClientBuilder.build()
					.post()
					.uri("http://TRANSACTIONSERVICE")
					.bodyValue(transaction)
					.retrieve()
					.bodyToMono(Transaction.class)
					.block();
					
		} catch (Exception e) {
			throw new OrderNotFoundException("Transaction failed");
		}
    }
    private void deductBalance(Wallet wallet) {
    	try {
    		webClientBuilder.build()
    		.post()
    		.uri("http://WALLETSERVICE/deduct")
    		.bodyValue(wallet)
    		.retrieve()
    		.bodyToMono(Wallet.class)
    		.block();
    		
    	} catch (Exception e) {
    		throw new OrderNotFoundException("Insufficient balance for user: " + wallet.getUserId());
    	}
    }
    
    private User findUserDetails(String id) {
    	return webClientBuilder.build()
    			.get()
    			.uri("http://USERSERVICE/auth/"+id)
    			.retrieve()
    			.bodyToMono(User.class)
    			.block();
    }
    private void sendNotification(OrderPlacedEvent event) {
        try {
            webClientBuilder.build()
                .post()
                .uri("http://MAILSERVICE")
                .bodyValue(event)
                .retrieve()		
                .bodyToMono(Void.class)
                .block();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }


    @Override
    public Order updateOrderStatus(String id, String status) {
        Order existingOrder = orderRepository.findById(id)
                .orElseThrow(() -> new OrderNotFoundException(OrderServiceImpl.mess + id));

        existingOrder.setOrderStatus(status);
        return orderRepository.save(existingOrder);
    }

    @Override
    public void cancelOrder(String id) {
        Order existingOrder = orderRepository.findById(id)
                .orElseThrow(() -> new OrderNotFoundException(OrderServiceImpl.mess + id));

        existingOrder.setOrderStatus("CANCELLED");
        orderRepository.save(existingOrder);
    }

    @Override
    public Order getOrderById(String id) {
        return orderRepository.findById(id)
                .orElseThrow(() -> new OrderNotFoundException(OrderServiceImpl.mess + id));
    }

    @Override
    public List<Order> getOrdersByUserId(String userId) {
        return orderRepository.findByUserId(userId);
    }
}
